#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include "m_usb.h"

// SPI Pin Definitions for ATmega32U4
#define SPI_DDR  DDRB
#define SPI_PORT PORTB
#define MOSI     PB2
#define MISO     PB3
#define SCK      PB1
#define SS       PB0 // Slave Select pin for PCAP04

// PCAP04 SPI Commands
#define OPCODE_WRITE_CFG    0xA3
#define OPCODE_READ_CFG     0x23
#define OPCODE_READ_RES     0x40  // plus address
#define OPCODE_POR          0x88
#define OPCODE_INIT         0x8A
#define OPCODE_CDC_START    0x8C
#define OPCODE_TEST_READ    0x7E
#define WR_MEM 		0xA0
#define RD_MEM 		0x20
#define DSP_TRIG 0x8D


// Standard Firmware, <PCap04_standard_v1.hex>, Bytewise
// 34 Rows x 16 Bytes  +  1 Rows x 4 Bytes  = 548 Bytes
uint8_t standard_fw[548] = {
	0x24, 0x05, 0xA0, 0x01, 0x20, 0x55, 0x42, 0x5C, 0x48, 0xB1, 0x07, 0x92, 0x02, 0x20, 0x13, 0x02,
	0x20, 0x93, 0x02, 0xB2, 0x02, 0x78, 0x20, 0x54, 0xB3, 0x06, 0x91, 0x00, 0x7F, 0x20, 0x86, 0x20,
	0x54, 0xB6, 0x03, 0x72, 0x62, 0x20, 0x54, 0xB7, 0x00, 0x00, 0x42, 0x5C, 0xA1, 0x00, 0x49, 0xB0,
	0x00, 0x49, 0x40, 0xAB, 0x5D, 0x92, 0x1C, 0x90, 0x02, 0x7F, 0x20, 0x86, 0x66, 0x67, 0x76, 0x77,
	0x66, 0x7A, 0xCF, 0xCD, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xDC, 0xE7, 0x41, 0x32, 0xAA,
	0x01, 0x99, 0xFD, 0x7B, 0x01, 0x7A, 0xCF, 0xEB, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC1,
	0xE7, 0x41, 0x32, 0x6A, 0xDE, 0x44, 0x7A, 0xCF, 0xEA, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x6A,
	0xDF, 0x44, 0x7A, 0xC4, 0xE7, 0x41, 0x32, 0xAB, 0x05, 0x7A, 0xC1, 0xE1, 0x43, 0xE0, 0x3A, 0x7A,
	0xC0, 0xE1, 0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE6, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A,
	0xEF, 0x44, 0x02, 0x20, 0x9D, 0x84, 0x01, 0x21, 0x2E, 0x21, 0x74, 0x20, 0x37, 0xC8, 0x7A, 0xE7,
	0x43, 0x49, 0x11, 0x6A, 0xD4, 0x44, 0x7A, 0xC1, 0xD8, 0xE6, 0x43, 0xE9, 0x44, 0x1C, 0x43, 0x13,
	0xAB, 0x63, 0x6A, 0xDE, 0x41, 0xAB, 0x0B, 0x46, 0x46, 0x46, 0x7A, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xE3, 0x41, 0x32, 0x1C, 0x44, 0xE9, 0x13, 0x6A, 0xD4, 0x13, 0x41, 0xAA, 0xDF, 0x7A, 0xC5, 0xE1,
	0x43, 0x49, 0xE0, 0x34, 0x7A, 0xCF, 0xE3, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0xDB, 0xC0, 0x27,
	0xE5, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41, 0x30, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x37, 0x7A,
	0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC1, 0xE1, 0xE6, 0x43, 0xE9, 0x44,
	0x25, 0xE0, 0x7A, 0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC0, 0xE7, 0x43,
	0xE9, 0x44, 0x25, 0xE0, 0x92, 0x10, 0x7A, 0xE1, 0x44, 0xE2, 0x44, 0xE3, 0x44, 0xE4, 0x44, 0xE5,
	0x44, 0xE6, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xC1, 0xD8, 0x24, 0x3E, 0x92, 0xFF, 0x02, 0x7A, 0xCF,
	0xD7, 0xE6, 0x43, 0xF1, 0x44, 0x7A, 0xD0, 0xE7, 0x43, 0x2A, 0x2A, 0x32, 0xAB, 0x03, 0x42, 0x5C,
	0x92, 0x03, 0x7A, 0xC0, 0xE1, 0x43, 0xD9, 0x27, 0x90, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41,
	0x32, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x11, 0x7A, 0xC2, 0x43, 0x7A, 0xE7, 0x44, 0x6A, 0xC6, 0x44,
	0x7A, 0xC3, 0x43, 0x7A, 0xE8, 0x44, 0x6A, 0xC7, 0x44, 0xC1, 0xD4, 0x24, 0x57, 0x7A, 0xC8, 0xE1,
	0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE7, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC7, 0xE1,
	0x41, 0x6A, 0xD4, 0x45, 0x5A, 0x25, 0x36, 0x46, 0x46, 0x46, 0x46, 0x7A, 0xE9, 0x44, 0x7A, 0xC0,
	0xE7, 0x43, 0x55, 0x7A, 0xEA, 0x45, 0x7A, 0xE9, 0x51, 0x1C, 0x43, 0x6A, 0xCA, 0x44, 0x1D, 0x43,
	0x6A, 0xCB, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
	0xE0, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
	0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
	0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCA, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
	0xAE, 0xEE, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
	0xEC, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
	0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
	0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCB, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
	0xAE, 0xED, 0x44, 0x02
};

// Initialize SPI in Master Mode
void SPI_Init(void)
{
	// Set MOSI, SCK, SS as output; MISO as input
	SPI_DDR |= (1 << MOSI) | (1 << SCK) | (1 << SS);
	SPI_DDR &= ~(1 << MISO);
	
	// Set SS high initially
	SPI_PORT |= (1 << SS);
	
	// Enable SPI, Master, CPOL=0, CPHA=1 (SPI Mode 1), fosc/16
	SPCR = (1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << SPR0);
}

// SPI transfer: send and receive one byte
uint8_t SPI_Transfer(uint8_t data)
{
	SPDR = data;
	while (!(SPSR & (1 << SPIF)));
	return SPDR;
}
// Function Prototypes
void SPI_Init(void);
uint8_t SPI_Transfer(uint8_t data);
void PCAP04_WriteRegister(uint8_t address, uint8_t data);
uint8_t PCAP04_ReadRegister(uint8_t address);
void PCAP04_Init(void);
void PCAP04_CDC_START(void);

// Write: send OPCODE_WRITE + address + data
void PCAP04_WriteRegister(uint8_t address, uint8_t data)
{
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(OPCODE_WRITE_CFG); // send write opcode
	SPI_Transfer(address | 0xC0);      // send target address
	SPI_Transfer(data);        // send data
	
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
}

// Read: send OPCODE_READ + address, then read response
uint8_t PCAP04_ReadRegister(uint8_t address)
{
	uint8_t val;
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(OPCODE_READ_CFG); // send read opcode
	SPI_Transfer(address | 0xC0);     // send target address
	val = SPI_Transfer(0x00); // read response
	
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
	return val;
}

uint8_t PCAP04_TestRead(void) {
	uint8_t val;
	SPI_PORT &= ~(1 << SS);
	_delay_ms(1);
	SPI_Transfer(OPCODE_TEST_READ);  // send test read opcode
	val = SPI_Transfer(0x00);        // get response
	_delay_ms(1);
	SPI_PORT |= (1 << SS);
	_delay_ms(1);
	return val;
}

void Write_Byte_Auto_Incr(uint8_t opcode, uint8_t address, const uint8_t* byte_array, int length)
{
	// Pull SS low to start SPI transaction
	SPI_PORT &= ~(1 << SS);
	_delay_ms(1);

	// Transmit opcode (2 bytes)

	SPI_Transfer(opcode);
	SPI_Transfer(address);

	// Send data sequentially
	for (int i = 0; i < length; i++) {

		SPI_Transfer(byte_array[i]);
		_delay_ms(5);
	}

	_delay_ms(10);
	SPI_PORT |= (1 << SS); // End transaction
	_delay_ms(1);
}

void Read_Byte_Auto_Incr(uint8_t opcode, uint8_t address, int length)
{

	uint8_t val=0;
	// Pull SS low to start SPI transaction
	SPI_PORT &= ~(1 << SS);
	_delay_ms(1);

	// Transmit opcode (2 bytes)

	SPI_Transfer(opcode);
	SPI_Transfer(address);
	for (int i = 0; i < length; i++) {
		val=SPI_Transfer(0x00);

	}


	SPI_PORT |= (1 << SS); // End transaction
	_delay_ms(1);
	
}
// Initialize PCAP04: example config
void PCAP04_CDC_START(void)
{
	// For example, write to config register 0x00
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(OPCODE_CDC_START); // send write opcode
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
}

void DSP_TRIG_ACTION(void)
{
	// For example, write to config register 0x00
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(DSP_TRIG); // send write opcode
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
}


void PCAP04_Init(void) {
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(OPCODE_INIT); // send write opcode
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
	PCAP04_WriteRegister(0x00, 0x01); // Set Oscillator Frequency to 50 kHz
	PCAP04_WriteRegister(0x04, 0b10010001); // CFG4: grounded sensor  + C_REF_INT
	PCAP04_WriteRegister(0x06, 0x3F); // CFG6: Enable PC0
	PCAP04_WriteRegister(0x07, 0x08); // CFG7: averaging = 8
	PCAP04_WriteRegister(0x08, 0x00); // CFG8: high byte of averaging
	PCAP04_WriteRegister(0x09, 0x19); // CFG9â€“11: CONV_TIME for 1 kHz
	PCAP04_WriteRegister(0x0A, 0x00);
	PCAP04_WriteRegister(0x0B, 0x00);
	PCAP04_WriteRegister(0x12, 0x00); // CFG12: Offset compensation (default)
	PCAP04_WriteRegister(0x13, 0x01); // CFG19: CDC_START = 1 (continuous mode, Table 70)
	PCAP04_WriteRegister(0x1B, 0x08); // CFG27: DSP_SPEED = 2 (Recommended, Table 88)
	PCAP04_WriteRegister(0x22, 0xF0); // CFG34: DSP_TRIG_BG = 1 (Enabled, Section 7.6.3.7)
	uint8_t reg36 = PCAP04_ReadRegister(0x24); // CFG36
	reg36 &= ~(0xFF); // Clear all bits
	reg36 |= (1 << 3) | (1 << 1); // DSP_CONT_EN = 1, DSP_START = 1
	PCAP04_WriteRegister(0x24, reg36); // CFG36: DSP_CONT_EN=1, DSP_START=1, others 0
	PCAP04_WriteRegister(0x2F, 0x01); // CFG47: RUNBIT = 1
	uint8_t reg17 = PCAP04_ReadRegister(0x11); // Read existing value
	reg17 &= 0x03;                       // Clear bits 6:2 (keep bits 1:0)
	reg17 |= (7 << 2);                  // Set C_REF_SEL = 7 (approx. 10 pF internal reference)
	PCAP04_WriteRegister(0x11, reg17);        // Write back updated value
}



uint32_t PCAP04_ReadResult(uint8_t address)
{
	uint32_t val = 0;
	SPI_PORT &= ~(1 << SS); // SS low
	_delay_ms(1);           // setup time
	
	SPI_Transfer(OPCODE_READ_RES | address); // Send read result opcode with address (0x40 + address)
	uint8_t byte1 = SPI_Transfer(0x00);  // MSB
	uint8_t byte2 = SPI_Transfer(0x00);
	uint8_t byte3 = SPI_Transfer(0x00);
	uint8_t byte4 = SPI_Transfer(0x00);
	
	
	val = ((uint32_t)byte1 << 24) | ((uint32_t)byte2 << 16) | ((uint32_t)byte3 << 8) | ((uint32_t)byte4);



	
	_delay_ms(1);           // hold time
	SPI_PORT |= (1 << SS); // SS high
	_delay_ms(1);
	return val;
}

float binaryFractionToDecimal(uint8_t frac_bits, uint8_t num_bits) {
	float result = 0.0;
	// Loop through each bit
	for (uint8_t i = 0; i < num_bits; i++) {
		// Check if bit is set
		if (frac_bits & (1 << (num_bits - 1 - i))) {
			// Add corresponding fractional value 2^-(i+1)
			result += 1.0f / (1 << (i + 1));
		}
	}
	return result;
}




// Main function
int main(void) {
	uint32_t result;
	m_usb_init();
	_delay_ms(1);
	SPI_Init();
	_delay_ms(1);
	PCAP04_Init();
	_delay_ms(1);

	Write_Byte_Auto_Incr(WR_MEM, 0x00, standard_fw, 548);
	_delay_ms(10);
	Read_Byte_Auto_Incr(RD_MEM, 0X00, 10);
	_delay_ms(10);
	PCAP04_WriteRegister(0x2F, 0x01); // CFG47: RUNBIT = 1
	_delay_ms(10);
	PCAP04_CDC_START();
	_delay_ms(20);
	
	while (1) {
		DSP_TRIG_ACTION();
        result = PCAP04_ReadResult(0x00); // 0x00 is the address for Res0
		//m_usb_tx_uint(result);         
		//m_usb_tx_push();
		_delay_ms(10);
		

		uint8_t int_part = (result >> 27) & 0x1F;           // Extract top 5 bits
		
		//unsigned int decimal_value=0;
		//decimal_value = (unsigned int)strtol(int_part, NULL, 16);



		uint32_t frac_raw = result & 0x07FFFFFF;            // Extract lower 27 bits
		float fraction_value = binaryFractionToDecimal(frac_raw, 16);
	
		//m_usb_tx_long(decimal_value);
		//m_usb_tx_string(".");
		m_usb_tx_long(fraction_value);
		m_usb_tx_push();
		_delay_ms(1);
		m_usb_tx_string("\n");
		m_usb_tx_push();
		_delay_ms(1);
		
		 
	}
}